# AutoNF
Automating the life cycle of virtual network functions - A monolithic implementation

## Goal

1. To understand and analyze the factors affecting the load on an MME.
2. Migrating and/or deploying extra MME to a geographical area.
3. To be done using NFV.

## Useful Commands

Create a docker network

```bash
docker network create --subnet=172.18.0.0/24 mynet123
```
Stop all containers

```bash
docker kill $(docker ps -q)
```

remove all containers

```bash
docker rm $(docker ps -a -q)
```
stop running all containers

```bash
docker stop $(docker ps -a -q)
```
remove all docker images

```bash
docker rmi $(docker images -q)
```
remove <none> images

```bash
docker system prune
```
to build docker image with the given name
```bash
docker build -t 'name' .
```

## Creating docker images for MME and eNodeB
* Docker image is created from the git repository code.
* Before creating the image, make sure that the hss.conf and user_db.csv file at MME end in the git repository are populated with around 1000 unique UEs.
These are the UEs that will be available to MME for authenticating purposes whenever any new UE sends an attach request.
* Use below command for generating static UEs at both the srsepc end (in file hss.conf and user_db.csv) and srsue end(generating configuration files in the conf/ folder to be used later during run command).
```bash
/media/extra-disk/mallesh/nfvUE/vipul/softle/vnfs/srsue$ python2 gen_script.py conf/ue.conf 1000
```

1. Create MME docker image (vlte)
```bash
docker build -t vlte .
```
2. Create eNodeB docker image (venb)
```bash
docker build -t venb .
```

The above docker image creation should take around 15 minutes.

## Execution
### Terminal 0:
Need to create a docker network to be used for all communication.
```bash
$docker network create --subnet=172.18.0.0/24 mynet123
```
### Terminal 1:
Run the MME docker container
```bash
/media/extra-disk/mallesh/nfvUE/vipul/AutoNF/src/vnfs/vMME $sh run.sh
[Execute below command inside docker] srsepc epc.conf
```
### Terminal 2:
Run the eNodeB docker container
```bash
/media/extra-disk/mallesh/nfvUE/vipul/AutoNF/src/vnfs/vENB $sh run.sh
[Execute below command inside docker] srsenb enb.conf
```
### Terminal 3:
Connect the docker MME to docker eNodeB
```bash
/media/extra-disk/mallesh/nfvUE/vipul/softle/controller_if $./run_controller.sh
[Check connect messages on MME console and eNodeB console]
```
### Terminal 4:
Connect the UEs with given arg
```bash
/media/extra-disk/mallesh/nfvUE/vipul/softle/vnfs/srsue $python2 run_script.py conf/ue.conf 100
```
Tested for 635 UEs on 200gb system.

### Terminal 5:
Collect the metrics for the docker running vlte docker image in a text file.
```bash
/media/extra-disk/mallesh/nfvUE/vipul $docker stats gallant_swanson > metric.txt
```
### Terminal 6:
Run the module (dcae + policy + controller) generated by the test.cpp file.
```bash
/media/extra-disk/mallesh/nfvUE/vipul $./a.out
[Check console messages here]
```
## Core Logic
1. **NFV Setup**
* Multiple UE’s running on a machine.
* Every UE with a different configuration using a simple .py script (Subscriber key, IMSI, IMEI, port number)
* One eNodeB running in a docker container.
Created with a static docker IP (172.18.0.22)
* One MME running in a docker container. 
Created with a static docker IP (172.18.0.23)
2. **Communication**
* All UE’s listen on a different port number supplied via dynamically generated conf file.
* Port number is attached in the transmitting packet to eNodeB.
* eNodeB maintains a ue_context_map. Every UE that connects to it is given a random id. 
Ue_context_map[rid] =  {eNB_UE_S1AP_ID, MME_UE_S1AP_ID, port_num}
* MME registers UE with the same data.
3. **DCAE implementation**
* Capturing docker statistics for MME container in a txt file. DCAE polls over this file every 10 sec.
4. **Policy thresholds**
* Scaling thresholds: Heavily loaded MME if CPU utilization over 15% for consecutive three times
5. **Controller Actions**
* Spawning new MME docker containers when dockers get heavily loaded.
